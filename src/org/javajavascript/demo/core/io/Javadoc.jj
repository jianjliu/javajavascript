/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Javadoc.jj */
/*@egen*/
/*
 *  JavaDoq 1.0 - DOCUment JAVA In Source
 *  Copyright (C) 2008-2011  J.J.Liu<jianjunliu@126.com> <http://www.javadoq.com>
 *  
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *  
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

options {
  JDK_VERSION = "1.5";
  JAVA_UNICODE_ESCAPE = true;
               
                         
                           
                         
                          
  STATIC = false;
  TOKEN_EXTENDS = "AbstractToken";
  UNICODE_INPUT = true;
}

PARSER_BEGIN(JavadocParser)

package org.javajavascript.demo.core.io;

public class JavadocParser/*@bgen(jjtree)*/implements JavadocParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTJavadocParserState jjtree = new JJTJavadocParserState();

/*@egen*/

	void jjtreeOpenNodeScope(Node n) {
		((ASTNode)n).firstToken = getToken(1);
	}

	void jjtreeCloseNodeScope(Node n) {
		((ASTNode)n).lastToken = getToken(0);
	}
}

PARSER_END(JavadocParser)

TOKEN [IGNORE_CASE] :
{
  < LINK_START: "{@link" ( [" ", "\t"] )+ > : IN_LINK_START
| < SEE_START: "@see" ( [" ", "\t"] )+ > : IN_SEE_START
| < ANCHOR_START: "<a" ( [" ", "\t"] )+ "href" ( [" ", "\t"])* "=" ( [" ", "\t"] )* > : IN_ANCHOR_START
| < SPACE:    ( <WS> )+ >
| < #WS:      [" ", "\t", "\r", "\n", "\f"] >
| < COMMENT: ~[] >
}

<IN_LINK_START> TOKEN:
{
  < LINK:  ( ~["{", "}", "(", ")", "<", ">", " ", "\t", "\r", "\n", "\f"] )+ >
| < LINK_CLOSE: ( "(" (~["(", ")"])* ")" )? ( [" ", "\t"] )* "}" > : DEFAULT
}

<IN_SEE_START> TOKEN:
{
  < SEE:  ( ~["{", "}", "(", ")", "<", ">", " ", "\t", "\r", "\n", "\f"] )+ >
| < SEE_CLOSE: ( "(" (~["(", ")"])* ")" )? ( [" ", "\t", "\r", "\n", "\f"] )+ > : DEFAULT
}

<IN_ANCHOR_START> TOKEN:
{
  < ANCHOR:  (~[">", " ", "\t", "\r", "\n", "\f"])+ >
| < ANCHOR_CLOSE: ">" | ( ( [" ", "\t"] )+ ( ~[">"] )* ">" ) > : DEFAULT
}

ASTCompilationUnit CompilationUnit()                  :
{/*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit jjtn000 = new ASTCompilationUnit(this, JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompilationUnit */
  try {
/*@egen*/
  (    Link()
|   See()
|   Anchor()
|   < SPACE >
|   < COMMENT >
  )*
  < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  {    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void Link() :
{}
{
  < LINK_START >
  ( < LINK > ) ?
  < LINK_CLOSE >
}

void See() :
{}
{
  < SEE_START >
  ( < SEE > ) ?
  < SEE_CLOSE >
}

void Anchor() :
{}
{
  < ANCHOR_START >
  ( < ANCHOR > ) ?
  < ANCHOR_CLOSE >
}
